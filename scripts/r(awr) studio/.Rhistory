library(readr)
MonkeyDemographics_cov <- read_csv("Plotting for monkeys/MonkeyDemographics_cov.csv")
View(MonkeyDemographics_cov)
# Replace 'your_file_path' with the actual path to your CSV file
data <- read.csv("/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv")
data <- read.csv("/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv")
library(readr)
MonkeyDemographics_cov <- read_csv("Plotting for monkeys/MonkeyDemographics_cov.csv")
View(MonkeyDemographics_cov)
data <- read.csv("/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv")
# Load the knitr package
library(knitr)
# Assuming your data is stored in the 'data' data frame, you can create a table
kable(data,
format = "markdown",  # You can choose a different format if needed
col.names = c("Count", "Males", "Females", "Mean Age", "Maximum Age", "Standard Deviation Age"),
caption = "Monkey Demographics"
)
data <- read.csv("/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv")
# Load the knitr package
library(knitr)
# Assuming your data is stored in the 'data' data frame, you can create a table
kable(data,
format = "markdown",  # You can choose a different format if needed
col.names = c("Count", "Males", "Females", "Mean Age", "Maximum Age", "Standard Deviation Age"),
caption = "Monkey Demographics"
)
data <- read.csv("/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv")
# Load the knitr package
library(knitr)
# Assuming your data is stored in the 'data' data frame, you can create a table
kable(data,
format = "markdown",  # You can choose a different format if needed
col.names = c("Count", "Males", "Females", "Mean Age", "Maximum Age", "Standard Deviation Age"),
caption = "Monkey Demographics"
)
# Load the knitr package
library(knitr)
# Assuming your data is stored in the 'data' data frame, you can create a table
kable(data,
format = "markdown",  # You can choose a different format if needed
col.names = c("Count", "Males", "Females", "Mean Age", "Maximum Age", "Standard Deviation Age"),
caption = "Monkey Demographics"
)
library(readr)
MonkeyDemographics_cov <- read_csv("Plotting for monkeys/MonkeyDemographics_cov.csv")
View(MonkeyDemographics_cov)
install.packages("gt")
data %>%
gt() %>%
tab_header(title = md("What a **nice title**"),
subtitle = md("Pretty *cool subtitle* too, `isn't it?`"))
# Provide the file path to your CSV file
file_path <- "/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/monkey_demographics_cov.csv"
# Read the CSV file into an R data frame
MonkeyDemographics_cov <- read.csv(file_path)
# Provide the file path to your CSV file
file_path <- "/Users/similovesyou/Desktop/r(awr) studio/Plotting for monkeys/MonkeyDemographics_cov.csv"
# Read the CSV file into an R data frame
MonkeyDemographics_cov <- read.csv(file_path)
# View the data frame to check if the data was loaded correctly
View(MonkeyDemographics_cov)
data %>%
gt() %>%
tab_header(title = md("What a **nice title**"),
subtitle = md("Pretty *cool subtitle* too, `isn't it?`"))
install.packages("gptstudio")
pak::pak("MichelNivard/gptstudio")
require(usethis)
edit_r_environ()
pip install openai
npm install openai
install.packages(c("httr", "jsonlite", "dplyr", "tibble"))
library(GPTStudio)
library(gptstudio)
library(httr)
library(jsonlite)
# Function to call the OpenAI API
chat_gpt <- function(prompt, api_key, model = "gpt-4", max_tokens = 100) {
url <- "https://api.openai.com/v1/completions"
# Define the body of the API request
body <- list(
model = model,
prompt = prompt,
max_tokens = max_tokens,
temperature = 0.7
)
# Make the API request
response <- POST(
url,
add_headers(
Authorization = paste("Bearer", api_key),
`Content-Type` = "application/json"
),
body = toJSON(body, auto_unbox = TRUE)
)
file.edit("~/.Renviron")
# Parse and return the response
content <- content(response, as = "parsed", simplifyVector = TRUE)
return(content$choices[[1]]$text)
}
file.edit("~/.Renviron")
api_key <- Sys.getenv("OPENAI_API_KEY")
response <- chat_gpt(prompt = "Explain R programming.", api_key = api_key, model = "gpt-4", max_tokens = 150)
cat(response)
response <- chat_gpt(prompt = "Explain R programming.", api_key = api_key, model = "gpt-4", max_tokens = 150)
install.packages("httr")
library(httr)
response <- chat_gpt(prompt = "Explain R programming.", api_key = api_key, model = "gpt-4", max_tokens = 150)
install.packages("jsonlite")
library(jsonlite)
response <- chat_gpt(prompt = "Explain R programming.", api_key = api_key, model = "gpt-4", max_tokens = 150)
cat(response)
response <- chat_gpt(prompt = "Explain R programming.", api_key = api_key, model = "gpt-4", max_tokens = 150)
cat(response)
install.packages("pak")
pak::pak("usethis")
pak::pak("michelnivard/gptstudio")
usethis::edit_r_environ()
restart
sys.getin("OPENAI_API_KEY")
Sys.getenv("OPENAI_API_KEY")
gptstudio:::gptstudio_chat()
gptstudio:::gptstudio_chat()
gptstudio:::gptstudio_chat()
gptstudio:::gptstudio_chat()
system("/Users/similovesyou/.Renviron")
gptstudio:::gptstudio_chat()
# Required libraries
library(ggraph)
library(igraph)
library(tidyverse)
library(RColorBrewer)
# Create a data frame giving the hierarchical structure of your individuals
set.seed(1234)
# First level: Using your provided groups
group_data <- data.frame(
Index = c(1, 90, 138, 231, 501, 590, 638, 731),
Abbreviation = c("CL_Frontal", "CL_Parietal", "CL_Temporal", "CL_Occipital",
"CR_Frontal", "CR_Parietal", "CR_Temporal", "CR_Occipital"),
Full_Name = c("CL_Frontal_Lobe", "CL_Parietal_Lobe", "CL_Temporal_Lobe", "CL_Occipital_Lobe",
"CR_Frontal_Lobe", "CR_Parietal_Lobe", "CR_Temporal_Lobe", "CR_Occipital_Lobe"),
First_Level = rep(1, 8),
Last_Level = rep(1, 8)
)
# Define first-level hierarchy (origin to groups)
d1 <- data.frame(from = "origin", to = group_data$Abbreviation)
# Define second-level hierarchy with new data
d2_data <- data.frame(
Index = c(2, 16, 50, 77, 91, 96, 112, 125, 139, 165, 175, 193, 204, 224, 232, 233, 246, 502, 516, 550, 577, 591, 596, 612, 625, 639, 665, 675, 693, 704, 724, 732, 733, 746),
Abbreviation = c("CL_ACgG", "CL_OFC", "CL_lat_PFC", "CL_motor", "CL_SI/SII", "CL_SPL", "CL_IPL", "CL_PMC", "CL_MTL", "CL_TG", "CL_ITC", "CL_STG/STSd", "CL_core/belt", "CL_floor_of_ls", "CL_MT", "CL_V2-V4", "CL_V1", "CR_ACgG", "CR_OFC", "CR_lat_PFC", "CR_motor", "CR_SI/SII", "CR_SPL", "CR_IPL", "CR_PMC", "CR_MTL", "CR_TG", "CR_ITC", "CR_STG/STSd", "CR_core/belt", "CR_floor_of_ls", "CR_MT", "CR_V2-V4", "CR_V1"),
Full_Name = c("CL_anterior_cingulate_gyrus", "CL_orbital_frontal_cortex", "CL_lateral_prefrontal_cortex", "CL_motor_cortex", "CL_somatosensory_cortex", "CL_superior_parietal_lobule", "CL_inferior_parietal_lobule", "CL_posterior_medial_cortex", "CL_medial_temporal_lobe", "CL_temporal_pole", "CL_inferior_temporal_cortex", "CL_superior_temporal_region", "CL_core_and_belt_areas_of_auditory_cortex", "CL_floor_of_the_lateral_sulcus", "CL_middle_temporal_area", "CL_extrastriate_visual_areas_2-4", "CL_primary_visual_cortex", "CR_anterior_cingulate_gyrus", "CR_orbital_frontal_cortex", "CR_lateral_prefrontal_cortex", "CR_motor_cortex", "CR_somatosensory_cortex", "CR_superior_parietal_lobule", "CR_inferior_parietal_lobule", "CR_posterior_medial_cortex", "CR_medial_temporal_lobe", "CR_temporal_pole", "CR_inferior_temporal_cortex", "CR_superior_temporal_region", "CR_core_and_belt_areas_of_auditory_cortex", "CR_floor_of_the_lateral_sulcus", "CR_middle_temporal_area", "CR_extrastriate_visual_areas_2-4", "CR_primary_visual_cortex"),
First_Level = rep(2, 34),
Last_Level = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 6, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 6, 2, 6)
)
# Correcting the replication to avoid mismatched rows
d2 <- data.frame(
from = rep(d1$to, each = ceiling(nrow(d2_data) / nrow(d1))),
to = d2_data$Abbreviation[1:(nrow(d1) * ceiling(nrow(d2_data) / nrow(d1)))]
)
# Combine edges
edges <- rbind(d1, d2)
# Create a dataframe with random connections between leaves (individuals)
all_leaves <- d2$to
connect <- rbind(
data.frame(from = sample(all_leaves, 100, replace = TRUE),
to = sample(all_leaves, 100, replace = TRUE)),
data.frame(from = sample(head(all_leaves), 30, replace = TRUE),
to = sample(tail(all_leaves), 30, replace = TRUE)),
data.frame(from = sample(all_leaves[1:5], 30, replace = TRUE),
to = sample(all_leaves[6:10], 30, replace = TRUE))
)
connect$value <- runif(nrow(connect))
# Create a vertices data.frame
vertices <- data.frame(
name = unique(c(as.character(edges$from), as.character(edges$to))),
value = runif(length(unique(c(as.character(edges$from), as.character(edges$to)))))
)
# Add group information to vertices
vertices$group <- edges$from[match(vertices$name, edges$to)]
# Calculate label angles and alignment
vertices$id <- NA
myleaves <- which(is.na(match(vertices$name, edges$from)))
nleaves <- length(myleaves)
vertices$id[myleaves] <- seq(1:nleaves)
vertices$angle <- 90 - 360 * vertices$id / nleaves
vertices$hjust <- ifelse(vertices$angle < -90, 1, 0)
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle + 180, vertices$angle)
# Create a graph object
mygraph <- igraph::graph_from_data_frame(edges, vertices = vertices)
# Update connection indices for the graph
from <- match(connect$from, vertices$name)
to <- match(connect$to, vertices$name)
# Plot the hierarchical structure with connections
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) +
geom_node_point(aes(filter = leaf, x = x * 1.05, y = y * 1.05)) +
geom_conn_bundle(data = get_con(from = from, to = to), alpha = 0.2, colour = "skyblue", width = 0.9) +
geom_node_text(aes(x = x * 1.1, y = y * 1.1, filter = leaf, label = name, angle = angle, hjust = hjust),
size = 1.5, alpha = 1) +
theme_void() +
theme(
legend.position = "none",
plot.margin = unit(c(0, 0, 0, 0), "cm")
) +
expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2))
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) +
geom_conn_bundle(data = get_con(from = from, to = to), alpha = 0.2, width = 0.9, aes(colour = ..index..)) +
scale_edge_colour_distiller(palette = "RdPu") +
geom_node_text(aes(x = x * 1.15, y = y * 1.15, filter = leaf, label = name, angle = angle, hjust = hjust, colour = group),
size = 2, alpha = 1) +
geom_node_point(aes(filter = leaf, x = x * 1.07, y = y * 1.07, colour = group, size = value, alpha = 0.2)) +
scale_colour_manual(values = rep(brewer.pal(9, "Paired"), 30)) +
scale_size_continuous(range = c(0.1, 10)) +
theme_void() +
theme(
legend.position = "none",
plot.margin = unit(c(0, 0, 0, 0), "cm")
) +
expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))
